# Mini DB

キー・バリューストアのネットワークサーバー実装。`select()`を使用したマルチクライアント対応のTCPサーバーです。

## コンパイル方法

このプロジェクトはC++で書かれており、以下の方法でコンパイルできます。

### 方法1: g++を使用（推奨）

```bash
g++ -Wall -Wextra -Werror mini_db.cpp -o mini_db
```

`g++`はC++コンパイラで、C++標準ライブラリを自動的にリンクします。

### 方法2: gccを使用

```bash
gcc -Wall -Wextra -Werror -lstdc++ mini_db.cpp -o mini_db
```

`gcc`でC++コードをコンパイルする場合、`-lstdc++`オプションでC++標準ライブラリを明示的にリンクする必要があります。

**注意**: `gcc -Wall -Wextra -Werror mini_db.cpp`だけでは、C++標準ライブラリがリンクされずにリンクエラーが発生します。

## 実行方法

```bash
./mini_db <port> <database_file>
```

- `port`: サーバーがリッスンするポート番号
- `database_file`: データベースファイルのパス

## 使用方法

サーバーは以下のコマンドを受け付けます：

- `POST <key> <value>`: キーと値を保存（返信: `0\n`）
- `GET <key>`: キーの値を取得（返信: `0 <value>\n` または `1\n`）
- `DELETE <key>`: キーを削除（返信: `0\n` または `1\n`）

不正なコマンドの場合は `2\n` を返します。

Ctrl+C（SIGINT）でサーバーを終了すると、データベースがファイルに保存されます。

## コードの全体構造

このプログラムは、キー・バリューストアのネットワークサーバーです。`select()`を使ったマルチクライアント対応のTCPサーバーです。

### 1. プログラム起動時の流れ

```
main() 開始
  ↓
引数チェック (ポート番号、ファイルパス)
  ↓
SIGINTシグナルハンドラ登録 (handler関数)
  ↓
データベースファイル読み込み (readDb関数)
  ↓
Serverオブジェクト作成
  ↓
server.run() 実行
```

### 2. データベースの読み込み・保存

**起動時:**
```
readDb() → ファイルから key-value ペアを読み込み → db (std::map) に格納
```

**終了時 (SIGINT受信):**
```
handler() → db の内容をファイルに書き込み → プログラム終了
```

### 3. サーバーの動作フロー

```
server.run()
  ↓
bindAndListen() → ソケットをバインド・リッスン開始
  ↓
"ready" を出力
  ↓
[メインループ開始]
  ↓
select() で接続待機
  ↓
┌─────────────────────────────────────┐
│ 新しい接続?                          │
│ → accept() でクライアント受付        │
│ → FD_SET で監視対象に追加            │
└─────────────────────────────────────┘
  ↓
┌─────────────────────────────────────┐
│ 既存クライアントからのメッセージ?    │
│ → pullMessage() で受信              │
│ → handlemessage() で処理            │
│   ├─ POST: db[key] = value          │
│   ├─ GET: db[key] を検索・返送       │
│   └─ DELETE: db[key] を削除          │
└─────────────────────────────────────┘
  ↓
[ループ継続]
```

### 4. クラス構造

```
Socket クラス
├─ ソケット作成・設定
├─ bindAndListen() - バインド・リッスン
├─ accept() - クライアント接続受付
└─ pullMessage() - メッセージ受信

Server クラス
├─ Socket _listeningSocket - リスニングソケット
├─ std::map &db - データベースへの参照
├─ fd_set (rfds, wfds, afds) - select用のファイルディスクリプタセット
└─ run() - メインループ
    └─ handlemessage() - コマンド処理
```

### 5. コマンド処理の詳細

コマンド処理の流れ:

1. メッセージをパース（command, key, value）
2. **POST**: `db[key] = value` → 返信 `"0\n"`
3. **GET**: `db.find(key)` → 見つかれば `"0 <value>\n"`、なければ `"1\n"`
4. **DELETE**: `db.erase(key)` → 成功なら `"0\n"`、失敗なら `"1\n"`
5. **その他**: `"2\n"`（エラー）

### 6. 全体フロー図

```
┌─────────────────────────────────────────────────────────┐
│                   プログラム起動                         │
│  main(port, filepath)                                    │
└──────────────────┬──────────────────────────────────────┘
                   │
                   ▼
        ┌──────────────────────┐
        │  SIGINTハンドラ登録   │
        │  (handler関数)        │
        └──────────────────────┘
                   │
                   ▼
        ┌──────────────────────┐
        │  データベース読み込み │
        │  readDb()             │
        │  ファイル → db(map)    │
        └──────────────────────┘
                   │
                   ▼
        ┌──────────────────────┐
        │  Server作成・起動     │
        │  server.run()         │
        └──────────────────────┘
                   │
                   ▼
        ┌──────────────────────┐
        │  bindAndListen()      │
        │  "ready" 出力         │
        └──────────────────────┘
                   │
                   ▼
        ┌─────────────────────────────────────┐
        │     メインループ (while(true))       │
        │                                     │
        │  select() で接続待機                │
        │                                     │
        │  ┌─────────────────────────────┐   │
        │  │ 新規接続?                    │   │
        │  │ → accept()                  │   │
        │  │ → FD_SET に追加             │   │
        │  └─────────────────────────────┘   │
        │                                     │
        │  ┌─────────────────────────────┐   │
        │  │ 既存クライアントからの       │   │
        │  │ メッセージ?                 │   │
        │  │ → pullMessage()             │   │
        │  │ → handlemessage()           │   │
        │  │   ├─ POST/GET/DELETE        │   │
        │  │   └─ レスポンス送信         │   │
        │  └─────────────────────────────┘   │
        └─────────────────────────────────────┘
                   │
                   │ (SIGINT受信時)
                   ▼
        ┌──────────────────────┐
        │  データベース保存     │
        │  handler()            │
        │  db(map) → ファイル   │
        └──────────────────────┘
                   │
                   ▼
                終了
```

### 7. 重要なポイント

- **マルチクライアント対応**: `select()`で複数クライアントを同時処理
- **データ永続化**: 起動時にファイルから読み込み、SIGINTで保存
- **エラーハンドリング**: 各操作で適切なエラーコードを返送（0=成功、1=キーなし、2=不正コマンド）
- **リソース管理**: Socketクラスのデストラクタでソケットをクローズ

この実装により、複数のクライアントが同時に接続し、POST/GET/DELETEを実行できます。

## テスト方法

### 1. 手動テスト（netcat使用）

`nc` (netcat) を使用して手動でテストできます：

```bash
# サーバー起動
./mini_db 1111 .save &

# クライアント接続
nc localhost 1111

# コマンド送信例
POST A B
GET A
DELETE A
```

### 2. 自動テストスクリプト（test.sh）

基本的なコマンドシーケンスと永続化のテストを実行します：

```bash
./test.sh
```

**テスト内容:**
- POST/GET/DELETEコマンドの基本動作
- 存在しないキーへのアクセス
- 不正なコマンドの処理
- データ永続化（SIGINT後の再起動でデータが保持されるか）

### 3. 包括的テスト（completeTest.py）

より詳細なテストスイートを実行します：

```bash
# 実行権限を付与（初回のみ）
chmod +x completeTest.py

# テスト実行
python3 completeTest.py
```

**テスト内容:**
- **永続接続テスト**: 1つのセッションで複数のコマンドを実行
- **複数接続テスト**: 複数の別々の接続からの操作
- **永続化テスト**: サーバー再起動後のデータ保持

**出力例:**
```
🚀 Starting database tests...
✓ Server started successfully

=== Testing persistent connection (multiple commands in one session) ===
✓ POST A B -> '0' (expected: '0')
✓ POST B C -> '0' (expected: '0')
✓ GET A -> '0 B' (expected: '0 B')
...

🎉 All tests passed! (3/3)
```

## ファイル構成

- `mini_db.hpp`: メインの実装ファイル（クラス定義、関数実装を含む）
- `mini_db.cpp`: ヘッダーファイルのインクルードのみ
