# Mini DB

キー・バリューストアのネットワークサーバー実装。`select()`を使用したマルチクライアント対応のTCPサーバーです。

## コンパイル方法

このプロジェクトはC++で書かれており、以下の方法でコンパイルできます。

### 方法1: g++を使用（推奨）

```bash
g++ -Wall -Wextra -Werror mini_db.cpp -o mini_db
```

`g++`はC++コンパイラで、C++標準ライブラリを自動的にリンクします。

### 方法2: gccを使用

```bash
gcc -Wall -Wextra -Werror -lstdc++ mini_db.cpp -o mini_db
```

`gcc`でC++コードをコンパイルする場合、`-lstdc++`オプションでC++標準ライブラリを明示的にリンクする必要があります。

**注意**: `gcc -Wall -Wextra -Werror mini_db.cpp`だけでは、C++標準ライブラリがリンクされずにリンクエラーが発生します。

## 実行方法

```bash
./mini_db <port> <database_file>
```

- `port`: サーバーがリッスンするポート番号
- `database_file`: データベースファイルのパス

## 使用方法

サーバーは以下のコマンドを受け付けます：

- `POST <key> <value>`: キーと値を保存（返信: `0\n`）
- `GET <key>`: キーの値を取得（返信: `0 <value>\n` または `1\n`）
- `DELETE <key>`: キーを削除（返信: `0\n` または `1\n`）

不正なコマンドの場合は `2\n` を返します。

Ctrl+C（SIGINT）でサーバーを終了すると、データベースがファイルに保存されます。

## コードの全体構造

このプログラムは、キー・バリューストアのネットワークサーバーです。`select()`を使ったマルチクライアント対応のTCPサーバーです。

### 1. プログラム起動時の流れ

```
main() 開始
  ↓
引数チェック (ポート番号、ファイルパス)
  ↓
データベースファイル読み込み (g_db に格納)
  ↓
ソケット作成・バインド・リッスン開始
  ↓
SIGINTシグナルハンドラ登録 (save_db_and_exit関数)
  ↓
"ready" を出力
  ↓
メインループ開始 (while(true))
```

### 2. データベースの読み込み・保存

**起動時:**
```
ファイルを開く → while (infile >> key >> val) で key-value ペアを読み込み → g_db (std::map) に格納
```

**終了時 (SIGINT受信):**
```
save_db_and_exit() → g_db の内容をファイルに書き込み → ファイルを閉じる → プログラム終了
```

### 3. サーバーの動作フロー

```
メインループ (while(true))
  ↓
select() で接続待機
  ↓
┌─────────────────────────────────────┐
│ 新しい接続? (i == g_sockfd)         │
│ → accept() でクライアント受付        │
│ → FD_SET で監視対象に追加            │
│ → buffers[client_fd] = "" で初期化   │
│ → max_fd を更新                      │
└─────────────────────────────────────┘
  ↓
┌─────────────────────────────────────┐
│ 既存クライアントからのメッセージ?    │
│ → recv() で受信 (最大1000バイト)     │
│ → buffers[i] に追加                 │
│ → 改行文字('\n')で分割して処理       │
│ → コマンドをパース                  │
│   ├─ POST: g_db[key] = value        │
│   ├─ GET: g_db.count(key) で検索    │
│   └─ DELETE: g_db.erase(key)        │
│ → send_res() でレスポンス送信        │
└─────────────────────────────────────┘
  ↓
[ループ継続]
```

### 4. 関数構造

```
グローバル変数
├─ g_filename - データベースファイル名
├─ g_db - データベース (std::map<string, string>)
└─ g_sockfd - リスニングソケット

save_db_and_exit(int)
├─ SIGINTシグナルハンドラ
├─ データベースをファイルに保存
└─ プログラム終了

send_res(int fd, const string &msg)
└─ クライアントにレスポンスを送信

main(int ac, char **av)
├─ 引数チェック
├─ データベースファイル読み込み
├─ ソケット作成・バインド・リッスン
├─ SIGINTハンドラ登録
├─ "ready" 出力
└─ メインループ
    ├─ select() で接続待機
    ├─ 新規接続の処理
    └─ 既存接続からのメッセージ処理
        ├─ バッファリング (buffers[i])
        ├─ コマンドパース
        └─ コマンド実行・レスポンス送信
```

### 5. コマンド処理の詳細

コマンド処理の流れ:

1. 受信データをバッファに追加 (`buffers[i] += buf`)
2. 改行文字(`\n`)で分割して行ごとに処理
3. 行をパース（`stringstream`で `cmd`, `key`, `val` を抽出）
4. **POST**: `!key.empty() && !val.empty()` の場合、`g_db[key] = val` → 返信 `"0\n"`
5. **GET**: `!key.empty() && val.empty()` の場合、`g_db.count(key)` で検索 → 見つかれば `"0 " + g_db[key] + "\n"`、なければ `"1\n"`
6. **DELETE**: `!key.empty() && val.empty()` の場合、`g_db.erase(key)` → 成功なら `"0\n"`、失敗なら `"1\n"`
7. **その他**: 上記条件に合わない場合は `"2\n"`（エラー）を返す

### 6. 全体フロー図

```
┌─────────────────────────────────────────────────────────┐
│                   プログラム起動                         │
│  main(ac, av)                                            │
└──────────────────┬──────────────────────────────────────┘
                   │
                   ▼
        ┌──────────────────────┐
        │  引数チェック          │
        │  (ac != 3)            │
        └──────────────────────┘
                   │
                   ▼
        ┌──────────────────────┐
        │  データベース読み込み │
        │  ファイル → g_db(map)  │
        │  (while (infile >> key >> val)) │
        └──────────────────────┘
                   │
                   ▼
        ┌──────────────────────┐
        │  ソケット作成          │
        │  socket()             │
        └──────────────────────┘
                   │
                   ▼
        ┌──────────────────────┐
        │  バインド・リッスン    │
        │  bind() + listen()     │
        └──────────────────────┘
                   │
                   ▼
        ┌──────────────────────┐
        │  SIGINTハンドラ登録   │
        │  signal(SIGINT, save_db_and_exit) │
        └──────────────────────┘
                   │
                   ▼
        ┌──────────────────────┐
        │  "ready" 出力         │
        │  cout << "ready"      │
        └──────────────────────┘
                   │
                   ▼
        ┌─────────────────────────────────────┐
        │     メインループ (while(true))       │
        │                                     │
        │  select() で接続待機                │
        │  (current_sockets, ready_sockets)   │
        │                                     │
        │  ┌─────────────────────────────┐   │
        │  │ 新規接続? (i == g_sockfd)    │   │
        │  │ → accept()                  │   │
        │  │ → FD_SET に追加             │   │
        │  │ → buffers[client_fd] = ""    │   │
        │  │ → max_fd を更新             │   │
        │  └─────────────────────────────┘   │
        │                                     │
        │  ┌─────────────────────────────┐   │
        │  │ 既存クライアントからの       │   │
        │  │ メッセージ?                 │   │
        │  │ → recv() で受信             │   │
        │  │ → buffers[i] に追加         │   │
        │  │ → '\n' で分割               │   │
        │  │ → コマンドパース            │   │
        │  │   ├─ POST: g_db[key] = val │   │
        │  │   ├─ GET: g_db.count(key)   │   │
        │  │   └─ DELETE: g_db.erase(key)│   │
        │  │ → send_res() でレスポンス送信│   │
        │  └─────────────────────────────┘   │
        └─────────────────────────────────────┘
                   │
                   │ (SIGINT受信時)
                   ▼
        ┌──────────────────────┐
        │  データベース保存     │
        │  save_db_and_exit()   │
        │  g_db(map) → ファイル │
        │  file.close()         │
        └──────────────────────┘
                   │
                   ▼
                終了 (exit(0))
```

### 7. 重要なポイント

- **マルチクライアント対応**: `select()`で複数クライアントを同時処理
- **バッファリング**: 各クライアントごとに `map<int, string> buffers` でバッファを管理し、複数のコマンドを1つの接続で処理可能
- **データ永続化**: 起動時にファイルから読み込み、SIGINTで保存（`file.close()`でバッファをフラッシュ）
- **エラーハンドリング**: 各操作で適切なエラーコードを返送（0=成功、1=キーなし、2=不正コマンド）
- **リクエストサイズ制限**: `recv()`で最大1000バイトまで受信
- **リソース管理**: クライアント切断時に `close()` と `FD_CLR()` で適切にクリーンアップ

この実装により、複数のクライアントが同時に接続し、POST/GET/DELETEを実行できます。

## テスト方法

### 1. 手動テスト（netcat使用）

`nc` (netcat) を使用して手動でテストできます：

```bash
# サーバー起動
./mini_db 1111 .save &

# クライアント接続
nc localhost 1111

# コマンド送信例
POST A B
GET A
DELETE A
```

### 2. 自動テストスクリプト（test.sh）

基本的なコマンドシーケンスと永続化のテストを実行します：

```bash
./test.sh
```

**テスト内容:**
- POST/GET/DELETEコマンドの基本動作
- 存在しないキーへのアクセス
- 不正なコマンドの処理
- データ永続化（SIGINT後の再起動でデータが保持されるか）

### 3. 包括的テスト（completeTest.py）

より詳細なテストスイートを実行します：

```bash
# テスト実行
python3 completeTest.py
```

**テスト内容:**
- **永続接続テスト**: 1つのセッションで複数のコマンドを実行
- **複数接続テスト**: 複数の別々の接続からの操作
- **永続化テスト**: サーバー再起動後のデータ保持

**出力例:**
```
🚀 Starting database tests...
✓ Server started successfully

=== Testing persistent connection (multiple commands in one session) ===
✓ POST A B -> '0' (expected: '0')
✓ POST B C -> '0' (expected: '0')
✓ GET A -> '0 B' (expected: '0 B')
...

🎉 All tests passed! (3/3)
```

## ファイル構成

- `mini_db.hpp`: メインの実装ファイル（クラス定義、関数実装を含む）
- `mini_db.cpp`: ヘッダーファイルのインクルードのみ
